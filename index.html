<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShooymCord</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

<style>
:root { --bg-tertiary: #1e1f22; --bg-secondary: #2b2d31; --bg-primary: #313338; --header-primary: #f2f3f5; --header-secondary: #949ba4; --text-normal: #dbdee1; --accent: #5865f2; --input-bg: #383a40; --green: #23a559; --red: #fa777c; --warning-bg: rgba(250, 166, 26, 0.1); --warning-border: #faa61a; }
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg-primary); color: var(--text-normal); font-family: 'gg sans', sans-serif; height: 100vh; overflow: hidden; display: flex; }

/* Scrollbar Optimization */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: #2b2d31; }
::-webkit-scrollbar-thumb { background: #1a1b1e; border-radius: 4px; }
* { scrollbar-width: thin; scrollbar-color: #1a1b1e #2b2d31; }

/* Layout Columns */
.servers { width: 72px; background: var(--bg-tertiary); display: flex; flex-direction: column; align-items: center; padding-top: 12px; gap: 8px; flex-shrink: 0; }
.server-icon { width: 48px; height: 48px; background-color: var(--bg-primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: 0.2s; color: var(--text-normal); position: relative; }
.server-icon:hover, .server-icon.active { border-radius: 16px; background-color: var(--accent); color: white; }

.channels { width: 240px; background: var(--bg-secondary); display: flex; flex-direction: column; flex-shrink: 0; }
.server-header { height: 48px; padding: 0 16px; display: flex; align-items: center; font-weight: bold; box-shadow: 0 1px 0 rgba(4,4,5,0.2); color: var(--header-primary); }
.channel-list { padding: 8px; flex: 1; overflow-y: auto; }
.channel-item { padding: 6px 8px; margin-bottom: 2px; border-radius: 4px; color: var(--header-secondary); cursor: pointer; display: flex; align-items: center; gap: 6px; }
.channel-item:hover { background: rgba(79, 84, 92, 0.4); color: var(--text-normal); }
.channel-item.active { background: rgba(88, 101, 242, 0.3); color: white; }

/* User Bar (Bottom Left) */
.user-bar { background: #232428; height: 52px; padding: 0 8px; display: flex; align-items: center; gap: 8px; }
.user-avatar-small { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; object-fit: cover; background: #555; }
.user-info { flex: 1; font-size: 0.85rem; font-weight: bold; overflow: hidden; margin-left: 8px; }

/* Main Chat Area */
.chat-area { flex: 1; display: flex; flex-direction: column; background: var(--bg-primary); position: relative; min-width: 0; }
.chat-header { height: 48px; padding: 0 16px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 0 rgba(4,4,5,0.2); font-weight: bold; color: var(--header-primary); flex-shrink: 0;}
.header-left { display: flex; align-items: center; }
.header-right { display: flex; align-items: center; gap: 16px; }

#chat-feed { flex: 1; overflow-y: auto; padding: 16px 0; display: flex; flex-direction: column; }

/* Member List (Right Sidebar) */
.members-sidebar { width: 240px; background: var(--bg-secondary); display: flex; flex-direction: column; flex-shrink: 0; border-left: 1px solid #1e1f22; }
.members-header { padding: 16px 16px 8px; font-size: 0.75rem; font-weight: bold; text-transform: uppercase; color: var(--header-secondary); letter-spacing: 0.5px; }
.member-list { flex: 1; overflow-y: auto; padding: 0 8px 8px; }
.member-card { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 4px; cursor: pointer; opacity: 0.9; }
.member-card:hover { background: rgba(79, 84, 92, 0.4); opacity: 1; }
.member-avatar { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; background: #333; }
.member-name { font-weight: 500; color: var(--header-primary); font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* Messages */
.message { padding: 4px 16px; margin-top: 4px; display: flex; gap: 16px; border-left: 2px solid transparent; }
.message:hover { background: rgba(4, 4, 5, 0.07); }
.message.mentioned { background: var(--warning-bg); border-left: 2px solid var(--warning-border); }
.message.mentioned:hover { background: rgba(250, 166, 26, 0.15); }

.avatar { width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; background: #555; object-fit: cover; }
.message-header { display: flex; align-items: baseline; gap: 8px; }
.username { font-weight: 500; color: #fff; cursor: pointer; }
.username:hover { text-decoration: underline; color: var(--accent); }
.timestamp { font-size: 0.7rem; color: var(--header-secondary); }

/* File Attachments */
.msg-img { max-width: 300px; max-height: 300px; border-radius: 5px; margin-top: 5px; cursor: pointer; transition: opacity 0.2s; }
.msg-img:hover { opacity: 0.9; }
.msg-file { background: #2b2d31; padding: 10px; border-radius: 5px; display: inline-flex; align-items: center; gap: 10px; margin-top: 5px; text-decoration: none; color: var(--accent); border: 1px solid #444; }
.msg-file:hover { background: #333; }

/* Input Area */
.input-area { padding: 0 16px 24px; background: var(--bg-primary); }
.input-wrapper { background: var(--input-bg); border-radius: 8px; display: flex; align-items: center; padding: 10px 16px; gap: 10px; }
#msg-input { background: transparent; border: none; color: var(--text-normal); outline: none; width: 100%; font-family: inherit; font-size: 1rem; }
.btn-icon { background: none; border: none; color: #b5bac1; cursor: pointer; font-size: 1.2rem; transition: color 0.2s; }
.btn-icon:hover { color: var(--text-normal); }

/* Buttons & Badges */
#role-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; color: white; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
.role-host { background: var(--green); }
.role-client { background: var(--accent); }
.role-offline { background: var(--red); }
.role-migrating { background: #faa61a; color: black; } 

.call-btn { color: var(--header-secondary); cursor: pointer; font-size: 1.2rem; transition: 0.2s; background: none; border: none; }
.call-btn:hover { color: var(--header-primary); }

/* Hidden Inputs */
#pfp-upload, #file-upload { display: none; }

/* Responsive */
@media (max-width: 800px) {
    .members-sidebar { display: none; } /* Hide members on small screens */
}
</style>
</head>
<body>

<nav class="servers">
    <div class="server-icon active" onclick="resetToHome()" title="Home">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM11 7H13V9H14C15.1 9 16 9.9 16 11V15C16 16.1 15.1 17 14 17H11V19H9V17H8C6.9 17 6 16.1 6 15V11C6 9.9 6.9 9 8 9H11V7Z" fill="currentColor"/>
        </svg>
    </div>
</nav>

<div class="channels">
    <div class="server-header" id="server-name">Shooym Hub</div>
    <div class="channel-list">
        <div class="channel-item active" id="chan-general" onclick="switchChannel('general')">
            <span style="color:#888">#</span> General
        </div>
        <div class="channel-item" id="chan-cheating" onclick="switchChannel('cheating')">
            <span style="color:#888">#</span> Cheating General
        </div>
        <div class="channel-item" id="chan-dm" style="display:none; color: var(--accent);">
            <span style="color:var(--accent)">@</span> <span id="dm-username-display">User</span>
        </div>
    </div>
    
    <div class="user-bar">
        <label for="pfp-upload" title="Change Profile Picture">
            <img src="" id="current-user-avatar" class="user-avatar-small">
        </label>
        <input type="file" id="pfp-upload" accept="image/*" onchange="uploadPfp(this)">
        
        <div class="user-info">
            <div id="display-username" onclick="changeName()" style="cursor:pointer">...</div>
            <div style="font-size: 0.7rem; color: #aaa;">Online</div>
        </div>
    </div>
</div>

<main class="chat-area">
    <header class="chat-header">
        <div class="header-left">
            <span id="header-symbol" style="color:var(--header-secondary); margin-right: 4px;">#</span> 
            <span id="header-channel-name">general</span>
        </div>
        
        <div class="header-right">
            <button class="call-btn" onclick="openVoiceWindow()" title="Start Voice Call">
                <i class="fa-solid fa-phone"></i>
            </button>
            <div id="role-badge" class="role-offline">Starting...</div>
        </div>
    </header>

    <div id="chat-feed"></div>

    <div class="input-area">
        <div class="input-wrapper">
            <label for="file-upload" class="btn-icon" title="Send File (Img/PDF)">
                <i class="fa-solid fa-circle-plus"></i>
            </label>
            <input type="file" id="file-upload" accept="image/*,application/pdf" onchange="handleFileUpload(this)">
            
            <input type="text" id="msg-input" placeholder="Initializing..." disabled onkeydown="if(event.key==='Enter') sendMessage()">
            <button onclick="clearMyHistory()" class="btn-icon" title="Wipe History"><i class="fa-solid fa-trash"></i></button>
        </div>
    </div>
</main>

<aside class="members-sidebar">
    <div class="members-header">Online â€” <span id="online-count">1</span></div>
    <div class="member-list" id="member-list-container">
        </div>
</aside>

<script>
    // --- CONFIGURATION ---
    const SHARED_SERVER_ID = "shooym-global-room-v9-chan"; 
    const STORAGE_KEY = "shooym_history_v9";
    const PFP_KEY = "shooym_pfp_v1";

    // --- STATE ---
    let myName = localStorage.getItem("shooym_username");
    if(!myName) {
        myName = "User" + Math.floor(Math.random()*1000);
        localStorage.setItem("shooym_username", myName);
    }
    let myPfp = localStorage.getItem(PFP_KEY) || `https://ui-avatars.com/api/?name=${encodeURIComponent(myName)}&background=232428&color=fff`;

    let currentChannel = "general"; 
    let currentDMTarget = null; 
    let currentDMName = null;      

    let peer = null;
    let myRole = "offline"; 
    let connections = [];      
    let hostConn = null;       
    let messageHistory = [];
    let processedIds = new Set(); 
    let isMigrating = false;
    let isLocked = false; 

    // --- MEMBERS & NOTIFICATIONS ---
    let onlineUsers = []; // [{id, name, pfp}]
    let unreadMentions = 0;
    
    // --- FILTRATION ---
    const RAW_BAD_WORDS = ["mommy", "mommy", "mommy", "mommy", "daddy", "cunt", "penis", "nigger", "dick", "chink"];
    const LEET_MAP = { a: '[aA@4^/\\\\]', b: '[bB8|3]', c: '[cC{(<\\[]', d: '[dD|)\\>]', e: '[eE3]', f: '[fFph]', g: '[gG69]', h: '[hH#\\-|]', i: '[iI1!|l]', j: '[jJ]', k: '[kK|<]', l: '[lL1|!]', m: '[mM\\^\\^]', n: '[nN]', o: '[oO0]', p: '[pP9]', q: '[qQ9]', r: '[rR]', s: '[sS5$]', t: '[tT7+]', u: '[uUvV]', v: '[vV\\\\/]', w: '[wWvvVV]', x: '[xX%*]', y: '[yY]', z: '[zZ2]' };
    const SMART_FILTERS = RAW_BAD_WORDS.map(word => {
        let pattern = "";
        for (let char of word.toLowerCase()) { const sub = LEET_MAP[char] || char; pattern += sub + "+"; }
        return new RegExp(pattern, "gi");
    });

    // --- HEARTBEAT VARIABLES ---
    let lastHeartbeat = 0;
    let heartbeatInterval = null; 
    let monitorInterval = null;        

    // --- INITIALIZATION ---
    updateUI();
    loadHistory(); 
    initPeer();
    
    // Reset notification count on click
    window.addEventListener('click', () => {
        unreadMentions = 0;
        document.title = "ShooymCord";
    });

    // --- KEY LISTENER FOR WIPE (Ctrl+Shift+Backspace) ---
    window.addEventListener('keydown', (e) => {
        if(e.ctrlKey && e.shiftKey && e.key === 'Backspace') {
            e.preventDefault();
            triggerGlobalWipe();
        }
    });

    function openVoiceWindow() {
        window.open("call.html", "ShooymVoice", "width=380,height=600,menubar=no,toolbar=no,location=no");
    }

    // --- PEER INITIALIZATION ---
    function initPeer() {
        if(isMigrating) return;
        console.log("Initializing Peer...");
        resetHeartbeats(); 

        peer = new Peer(SHARED_SERVER_ID); 

        peer.on('open', (id) => {
            becomeHost(id);
        });

        peer.on('error', (err) => {
            if(err.type === 'unavailable-id') {
                console.log("Host exists. Switching to Client.");
                becomeClient();
            } else {
                // Retry if network blip
                setTimeout(initPeer, 3000);
            }
        });
    }

    // --- NAVIGATION & DMs ---
    function resetToHome() {
        switchChannel('general');
        document.getElementById('chan-dm').style.display = 'none';
    }

    function switchChannel(channelId) {
        currentChannel = channelId;
        currentDMTarget = null;
        document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
        if(channelId === 'general') document.getElementById('chan-general').classList.add('active');
        if(channelId === 'cheating') document.getElementById('chan-cheating').classList.add('active');
        const displayName = channelId === 'general' ? 'general' : 'cheating general';
        document.getElementById('header-symbol').innerText = '#';
        document.getElementById('header-channel-name').innerText = displayName;
        updateInputState();
        reRenderAllMessages();
    }

    function openDM(targetId, targetName) {
        if(!targetId || targetId === "undefined" || targetId === peer.id) return;
        currentChannel = 'dm';
        currentDMTarget = targetId;
        currentDMName = targetName;
        document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
        const dmBadge = document.getElementById('chan-dm');
        dmBadge.style.display = 'flex';
        dmBadge.classList.add('active');
        document.getElementById('dm-username-display').innerText = targetName;
        document.getElementById('header-symbol').innerText = '@';
        document.getElementById('header-channel-name').innerText = targetName;
        updateInputState();
        reRenderAllMessages();
    }

    function updateInputState() {
        const inp = document.getElementById('msg-input');
        if(isLocked) {
             inp.disabled = true;
             inp.placeholder = "ðŸ”’ CHANNEL LOCKED BY ADMIN";
        } else {
            inp.disabled = false;
            inp.placeholder = `Message ${currentChannel === 'dm' ? '@' + currentDMName : '#' + currentChannel}`;
            inp.focus();
        }
    }

    // --- HOST LOGIC ---
    function becomeHost(id) {
        myRole = 'host';
        updateRoleDisplay("HOST (You)");
        enableChat();
        connections = [];
        
        // Host adds self to list
        onlineUsers = [{id: id, name: myName, pfp: myPfp}];
        renderMemberList();

        heartbeatInterval = setInterval(() => { broadcast({ type: 'ping' }); }, 2000); 

        peer.on('connection', (conn) => {
            connections.push(conn);
            conn.on('open', () => {
                if(messageHistory.length > 0) {
                    messageHistory.forEach(msg => { if(msg.type !== 'dm') safeSend(conn, msg); });
                }
                // Send current user list to new connection
                safeSend(conn, { type: 'user-list-update', users: onlineUsers });
            });
            conn.on('data', (data) => {
                if(data.type === 'ping') return;

                // --- GLOBAL WIPE HANDLER (HOST) ---
                if(data.type === 'global-clear') {
                    handleGlobalClear();
                    broadcast(data); // Relay to all other clients
                    return;
                }
                
                // --- IDENTITY HANDSHAKE ---
                if (data.type === 'identify') {
                    // Update user info in list
                    const existingIdx = onlineUsers.findIndex(u => u.id === data.id);
                    if (existingIdx > -1) {
                        onlineUsers[existingIdx] = { id: data.id, name: data.user, pfp: data.pfp };
                    } else {
                        onlineUsers.push({ id: data.id, name: data.user, pfp: data.pfp });
                    }
                    broadcastUserList(); // Sync everyone
                    return;
                }

                // --- ADMIN INTERCEPTOR ---
                if (data.type === 'admin-cmd') {
                    if (typeof handleAdminData === "function") handleAdminData(data);
                    return; 
                }

                if(data.type === 'dm') {
                    if(isNewMessage(data.id)) {
                        processIncomingData(data); 
                        const targetConn = connections.find(c => c.peer === data.targetId);
                        if(targetConn) safeSend(targetConn, data);
                        const senderConn = connections.find(c => c.peer === data.senderId);
                        if(senderConn && senderConn !== targetConn) safeSend(senderConn, data);
                    }
                    return;
                }

                if(data.type === 'history-merge') { handleHistoryMerge(data.data); return; }
                if (isNewMessage(data.id)) { processIncomingData(data); broadcast(data); }
            });
            
            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
                // Remove from user list
                onlineUsers = onlineUsers.filter(u => u.id !== conn.peer);
                broadcastUserList();
            });
        });
    }

    function broadcast(data) {
        connections = connections.filter(c => c.open);
        connections.forEach(c => safeSend(c, data));
    }

    function safeSend(conn, data) {
        try {
            conn.send(data);
        } catch(e) {
            console.error("Send failed", e);
        }
    }
    
    function broadcastUserList() {
        const payload = { type: 'user-list-update', users: onlineUsers };
        broadcast(payload);
        renderMemberList(); // Render for host
    }

    // --- CLIENT LOGIC ---
    function becomeClient() {
        peer = new Peer(); 
        peer.on('open', () => {
            myRole = 'client';
            connectToHost();
        });
    }

    function connectToHost() {
        updateRoleDisplay("Connecting...");
        hostConn = peer.connect(SHARED_SERVER_ID);

        hostConn.on('open', () => {
            updateRoleDisplay("Connected");
            enableChat();
            
            // SEND IDENTITY TO HOST
            hostConn.send({ type: 'identify', id: peer.id, user: myName, pfp: myPfp });

            const publicHist = messageHistory.filter(m => m.type !== 'dm');
            if(publicHist.length > 0) {
                hostConn.send({ type: 'history-merge', data: publicHist });
            }
            
            lastHeartbeat = Date.now();
            monitorInterval = setInterval(checkHeartbeat, 1000); 
        });

        hostConn.on('data', (data) => {
            if(data.type === 'ping') { lastHeartbeat = Date.now(); return; }
            
            // --- GLOBAL WIPE HANDLER (CLIENT) ---
            if(data.type === 'global-clear') {
                handleGlobalClear();
                return;
            }

            if(data.type === 'user-list-update') {
                onlineUsers = data.users;
                renderMemberList();
                return;
            }

            if (data.type === 'admin-cmd') {
                if (typeof handleAdminData === "function") handleAdminData(data);
                return; 
            }
            if (isNewMessage(data.id)) { processIncomingData(data); }
        });

        hostConn.on('close', () => { handleHostDisconnect(); });
        peer.on('error', () => handleHostDisconnect());
    }

    // --- LIST RENDERING ---
    function renderMemberList() {
        const container = document.getElementById('member-list-container');
        document.getElementById('online-count').innerText = onlineUsers.length;
        container.innerHTML = '';
        
        onlineUsers.forEach(u => {
            const div = document.createElement('div');
            div.className = 'member-card';
            div.onclick = () => { if(u.id !== peer.id) openDM(u.id, u.name); };
            div.innerHTML = `
                <img src="${u.pfp}" class="member-avatar">
                <span class="member-name">${u.name} ${u.id === peer.id ? '(You)' : ''}</span>
            `;
            container.appendChild(div);
        });
    }

    // --- MERGE LOGIC ---
    function handleHistoryMerge(incomingHistory) {
        let dirty = false;
        incomingHistory.forEach(msg => {
            if(!processedIds.has(msg.id)) {
                processedIds.add(msg.id);
                messageHistory.push(msg);
                broadcast(msg);
                dirty = true;
            }
        });
        if(dirty) {
            messageHistory.sort((a, b) => a.timestamp - b.timestamp);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));
            reRenderAllMessages();
        }
    }

    // --- HEARTBEAT & DISCONNECT ---
    function checkHeartbeat() {
        if (Date.now() - lastHeartbeat > 15000) {
            console.warn("HEARTBEAT LOST!");
            handleHostDisconnect();
        }
    }

    function handleHostDisconnect() {
        if(isMigrating) return;
        isMigrating = true;
        resetHeartbeats(); 
        updateRoleDisplay("Host Dead! Migrating...", "migrating");
        disableChat();
        if(peer) peer.destroy();
        setTimeout(() => { isMigrating = false; initPeer(); }, Math.random() * 2000 + 1000);
    }

    function resetHeartbeats() {
        if(heartbeatInterval) clearInterval(heartbeatInterval);
        if(monitorInterval) clearInterval(monitorInterval);
    }

    // --- CORE MESSAGING ---
    function isNewMessage(id) {
        if(!id) return false;
        if(processedIds.has(id)) return false; 
        processedIds.add(id); 
        return true;
    }

    function processIncomingData(data) {
        const isOldMessage = (Date.now() - data.timestamp) > 5000;
        messageHistory.push(data);
        if(messageHistory.length > 300) messageHistory.shift(); 
        localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));

        let shouldRender = false;
        if (data.type === 'dm') {
            if (currentChannel === 'dm') {
                if ((data.targetId === peer.id && data.senderId === currentDMTarget) || 
                    (data.senderId === peer.id && data.targetId === currentDMTarget)) {
                    shouldRender = true;
                }
            }
        } else {
            if(data.channel === currentChannel || (!data.channel && currentChannel === 'general')) {
                shouldRender = true;
            }
        }

        if(shouldRender) {
            if(isOldMessage) {
                messageHistory.sort((a, b) => a.timestamp - b.timestamp);
                reRenderAllMessages();
            } else {
                renderMessage(data);
            }
        }
        
        // --- NOTIFICATION LOGIC ---
        if (!isOldMessage && data.senderId !== peer.id) {
            const regex = new RegExp("@" + myName, "i");
            if (regex.test(data.msg)) {
                unreadMentions++;
                document.title = `(${unreadMentions}) ShooymCord`;
            }
        }
    }

    function filterText(text) {
        if(!text) return "";
        let cleanText = text;
        SMART_FILTERS.forEach(regex => {
            cleanText = cleanText.replace(regex, (match) => "*".repeat(match.length));
        });
        return cleanText;
    }

    function sendMessage() {
        if(isLocked) return;

        const input = document.getElementById('msg-input');
        let text = input.value.trim();
        if (!text) return;
        text = filterText(text);

        const data = {
            id: Date.now().toString(36) + Math.random().toString(36).substr(2),
            user: myName,
            pfp: myPfp,
            msg: text,
            type: currentChannel === 'dm' ? 'dm' : 'text',
            channel: currentChannel === 'dm' ? null : currentChannel,
            targetId: currentChannel === 'dm' ? currentDMTarget : null,
            senderId: peer.id, 
            timestamp: Date.now()
        };

        if(myRole === 'host') {
            if(isNewMessage(data.id)) {
                processIncomingData(data);
                if(data.type === 'dm') {
                      const targetConn = connections.find(c => c.peer === data.targetId);
                      if(targetConn) safeSend(targetConn, data);
                } else broadcast(data);
            }
        } else {
            if(isNewMessage(data.id)) processIncomingData(data);
            dispatch(data);
        }
        input.value = '';
    }

    // --- FILE UPLOAD (OPTIMIZED) ---
    function handleFileUpload(input) {
        if(isLocked) return;
        const file = input.files[0];
        if (!file) return;

        // Compress images, leave PDFs alone
        if(file.type.match(/image.*/)) {
             compressImage(file, (compressedData) => {
                 sendFileData(compressedData, file.name, 'image');
             });
        } else if(file.type.includes('pdf')) {
             if (file.size > 2000000) { alert("PDF too big! Limit is 2MB."); return; }
             const reader = new FileReader();
             reader.onload = (e) => sendFileData(e.target.result, file.name, 'pdf');
             reader.readAsDataURL(file);
        } else {
            alert("Only Images and PDFs supported.");
        }
    }

    // Helper to resize/compress image before sending to avoid PeerJS crash
    function compressImage(file, callback) {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
            const img = new Image();
            img.src = event.target.result;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const MAX_WIDTH = 800; // Resize large images
                const scaleSize = MAX_WIDTH / img.width;
                canvas.width = (scaleSize < 1) ? MAX_WIDTH : img.width;
                canvas.height = (scaleSize < 1) ? img.height * scaleSize : img.height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                // Output as JPEG with 0.7 quality
                const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
                callback(dataUrl);
            };
        };
    }

    function sendFileData(dataStr, fileName, type) {
        const data = {
            id: Date.now().toString(36) + Math.random(),
            user: myName,
            pfp: myPfp,
            fileData: dataStr,
            fileName: fileName,
            type: currentChannel === 'dm' ? 'dm' : type,
            channel: currentChannel === 'dm' ? null : currentChannel,
            targetId: currentChannel === 'dm' ? currentDMTarget : null,
            senderId: peer.id,
            timestamp: Date.now()
        };

        if(myRole === 'host') {
            if(isNewMessage(data.id)) {
                processIncomingData(data);
                if(data.type === 'dm') {
                    const targetConn = connections.find(c => c.peer === data.targetId);
                    if(targetConn) safeSend(targetConn, data);
                } else broadcast(data);
            }
        } else {
            if(isNewMessage(data.id)) processIncomingData(data);
            dispatch(data);
        }
    }

    function dispatch(data) {
        if (myRole === 'host') broadcast(data);
        else if (myRole === 'client' && hostConn && hostConn.open) hostConn.send(data);
    }

    // --- GLOBAL WIPE FUNCTIONS ---
    function triggerGlobalWipe() {
        if(confirm("âš  WARNING: This will delete chat history for EVERYONE connected. Are you sure?")) {
            const data = { type: 'global-clear', id: Date.now().toString() };
            handleGlobalClear(); // Wipe my own
            dispatch(data); // Tell others
        }
    }

    function handleGlobalClear() {
        messageHistory = [];
        processedIds.clear();
        localStorage.removeItem(STORAGE_KEY);
        document.getElementById('chat-feed').innerHTML = '';
        console.log("Chat history has been wiped globally.");
    }

    function uploadPfp(input) {
        const file = input.files[0];
        if(!file) return;
        
        compressImage(file, (compressedData) => {
            myPfp = compressedData;
            localStorage.setItem(PFP_KEY, myPfp);
            updateUI();
            
            // Re-send identity to update list for everyone
            if (myRole === 'client' && hostConn) {
                hostConn.send({ type: 'identify', id: peer.id, user: myName, pfp: myPfp });
            } else if (myRole === 'host') {
                const me = onlineUsers.find(u => u.id === peer.id);
                if(me) { me.pfp = myPfp; broadcastUserList(); }
            }
        });
    }

    function changeName() {
        let newName = prompt("New Username:", myName);
        if(newName) {
            myName = newName;
            localStorage.setItem("shooym_username", myName);
            updateUI();
            
            // Re-send identity
            if (myRole === 'client' && hostConn) {
                hostConn.send({ type: 'identify', id: peer.id, user: myName, pfp: myPfp });
            } else if (myRole === 'host') {
                const me = onlineUsers.find(u => u.id === peer.id);
                if(me) { me.name = myName; broadcastUserList(); }
            }
        }
    }

    function loadHistory() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if(saved) {
                messageHistory = JSON.parse(saved);
                reRenderAllMessages();
            }
        } catch(e) {}
    }

    function clearMyHistory() {
        if(confirm("Clear local history?")) {
            localStorage.removeItem(STORAGE_KEY);
            messageHistory = [];
            processedIds.clear();
            document.getElementById('chat-feed').innerHTML = '';
        }
    }

    function updateUI() {
        document.getElementById('display-username').innerText = myName;
        document.getElementById('current-user-avatar').src = myPfp;
    }
    
    // --- UI HELPERS ---
    function enableChat() { document.getElementById('msg-input').disabled = false; updateInputState(); }
    function disableChat() { document.getElementById('msg-input').disabled = true; }
    function updateRoleDisplay(text, extraClass) {
        const b = document.getElementById('role-badge');
        b.innerText = text;
        b.className = '';
        if(extraClass) b.classList.add('role-' + extraClass);
        else if(myRole === 'host') b.classList.add('role-host');
        else if(myRole === 'client') b.classList.add('role-client');
        else b.classList.add('role-offline');
    }

    // --- RENDERERS ---
    function reRenderAllMessages() {
        const feed = document.getElementById('chat-feed');
        feed.innerHTML = '';
        messageHistory.forEach(msg => {
            processedIds.add(msg.id); 
            if(currentChannel === 'dm') {
                if(msg.type === 'dm') {
                    if((msg.senderId === peer.id && msg.targetId === currentDMTarget) || 
                       (msg.targetId === peer.id && msg.senderId === currentDMTarget)) {
                        renderMessage(msg);
                    }
                }
            } else {
                if(msg.channel === currentChannel || (!msg.channel && currentChannel === 'general')) {
                    if(msg.type !== 'dm') renderMessage(msg);
                }
            }
        });
        feed.scrollTop = feed.scrollHeight;
    }

    function renderMessage(data) {
        const feed = document.getElementById('chat-feed');
        const div = document.createElement('div');
        div.className = 'message';
        
        const divContent = document.createElement('div');
        divContent.style.flex = "1";

        let contentHTML = '';
        
        // Better type checking for attachments
        const isPdf = data.fileData && data.fileData.includes('application/pdf');
        
        if (isPdf) {
            contentHTML = `<br><a href="${data.fileData}" download="${data.fileName}" class="msg-file"><i class="fa-solid fa-file-pdf"></i> ${data.fileName}</a>`;
        } else if (data.fileData) {
            // Assume image if fileData exists and not PDF
            contentHTML = `<br><img src="${data.fileData}" class="msg-img" onclick="openImage('${data.fileData}')">`;
        } else {
            contentHTML = filterText(data.msg || "");
        }

        // --- CHECK MENTION ---
        const mentionRegex = new RegExp("@" + myName, "i");
        if (data.msg && mentionRegex.test(data.msg)) {
            div.classList.add('mentioned');
        }

        const dateStr = new Date(data.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const cleanName = filterText(data.user);
        
        div.innerHTML = `
            <img src="${data.pfp}" class="avatar">
            <div style="flex:1">
                <div class="message-header">
                    <span class="username" onclick="openDM('${data.senderId}', '${cleanName}')">${cleanName}</span>
                    <span class="timestamp">${dateStr}</span>
                </div>
                <div>${contentHTML}</div>
            </div>
        `;

        feed.appendChild(div);
        
        // Scroll fix: Wait for image to load before scrolling
        const imgs = div.querySelectorAll('img');
        if(imgs.length > 0) {
            imgs.forEach(img => img.onload = () => feed.scrollTop = feed.scrollHeight);
        }
        feed.scrollTop = feed.scrollHeight;
    }

    // --- FIX: MISSING FUNCTION ---
    function openImage(src) {
        const w = window.open("");
        w.document.write(`<body style="margin:0;background:#111;display:flex;justify-content:center;align-items:center;height:100vh;">
            <img src="${src}" style="max-width:100%;max-height:100%;box-shadow:0 0 20px rgba(0,0,0,0.5)">
        </body>`);
    }

</script>
</body>
</html>
