<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShooymCord</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

<style>
:root { --bg-tertiary: #1e1f22; --bg-secondary: #2b2d31; --bg-primary: #313338; --header-primary: #f2f3f5; --header-secondary: #949ba4; --text-normal: #dbdee1; --accent: #5865f2; --input-bg: #383a40; --green: #23a559; --red: #fa777c; }
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg-primary); color: var(--text-normal); font-family: 'gg sans', sans-serif; height: 100vh; overflow: hidden; display: flex; }

::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: #2b2d31; }
::-webkit-scrollbar-thumb { background: #1a1b1e; border-radius: 4px; }

/* Layout */
.servers { width: 72px; background: var(--bg-tertiary); display: flex; flex-direction: column; align-items: center; padding-top: 12px; gap: 8px; }
.server-icon { width: 48px; height: 48px; background-color: var(--bg-primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: 0.2s; color: var(--text-normal); position: relative; }
.server-icon.active { border-radius: 16px; background-color: var(--accent); color: white; }

.channels { width: 240px; background: var(--bg-secondary); display: flex; flex-direction: column; }
.server-header { height: 48px; padding: 0 16px; display: flex; align-items: center; font-weight: bold; box-shadow: 0 1px 0 rgba(4,4,5,0.2); color: var(--header-primary); }
.channel-list { padding: 8px; flex: 1; overflow-y: auto; }
.channel-item { padding: 6px 8px; margin-bottom: 2px; border-radius: 4px; color: var(--header-secondary); cursor: pointer; display: flex; align-items: center; gap: 6px; }
.channel-item:hover { background: rgba(79, 84, 92, 0.4); color: var(--text-normal); }
.channel-item.active { background: rgba(88, 101, 242, 0.3); color: white; }
.user-bar { background: #232428; height: 52px; padding: 0 8px; display: flex; align-items: center; gap: 8px; }
.user-avatar-small { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; object-fit: cover; background: #555; }
.user-info { flex: 1; font-size: 0.85rem; font-weight: bold; overflow: hidden; margin-left: 8px; }

.chat-area { flex: 1; display: flex; flex-direction: column; background: var(--bg-primary); position: relative; }
.chat-header { height: 48px; padding: 0 16px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 0 rgba(4,4,5,0.2); font-weight: bold; color: var(--header-primary); }
#chat-feed { flex: 1; overflow-y: auto; padding: 16px 0; display: flex; flex-direction: column; }

/* Messages */
.message { padding: 4px 16px; margin-top: 4px; display: flex; gap: 16px; position: relative; }
.message:hover { background: rgba(4, 4, 5, 0.07); }
.avatar { width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; background: #555; object-fit: cover; cursor: pointer; }
.message-header { display: flex; align-items: baseline; gap: 8px; }
.username { font-weight: 500; color: #fff; cursor: pointer; }
.username:hover { text-decoration: underline; }
.timestamp { font-size: 0.7rem; color: var(--header-secondary); }

/* File Attachments */
.msg-img { max-width: 300px; max-height: 300px; border-radius: 5px; margin-top: 5px; cursor: pointer; }
.msg-file { background: #2b2d31; padding: 10px; border-radius: 5px; display: inline-flex; align-items: center; gap: 10px; margin-top: 5px; text-decoration: none; color: var(--accent); border: 1px solid #444; }
.msg-file:hover { background: #333; }

/* Input Area */
.input-area { padding: 0 16px 24px; background: var(--bg-primary); }
.input-wrapper { background: var(--input-bg); border-radius: 8px; display: flex; align-items: center; padding: 10px 16px; gap: 10px; }
#msg-input { background: transparent; border: none; color: var(--text-normal); outline: none; width: 100%; font-family: inherit; font-size: 1rem; }
.btn-icon { background: none; border: none; color: #b5bac1; cursor: pointer; font-size: 1.2rem; transition: color 0.2s; }
.btn-icon:hover { color: var(--text-normal); }

/* Role Badge */
#role-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; color: white; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
.role-host { background: var(--green); }
.role-client { background: var(--accent); }
.role-offline { background: var(--red); }
.role-migrating { background: #faa61a; color: black; } 

/* CALLING UI */
#context-menu {
    position: fixed;
    background: #111214;
    border: 1px solid #2b2d31;
    border-radius: 4px;
    padding: 6px;
    display: none;
    z-index: 1000;
    box-shadow: 0 8px 16px rgba(0,0,0,0.4);
    min-width: 150px;
}
.ctx-item {
    padding: 8px 12px;
    color: #dbdee1;
    cursor: pointer;
    border-radius: 2px;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 8px;
}
.ctx-item:hover { background: #5865f2; color: white; }

#call-modal {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #1e1f22;
    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    display: none;
    z-index: 2000;
    border: 1px solid #2b2d31;
    width: 280px;
}
.call-status { font-weight: bold; margin-bottom: 12px; font-size: 1.1rem; }
.call-actions { display: flex; gap: 10px; justify-content: flex-end; }
.btn-call { padding: 8px 16px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; color: white; }
.btn-accept { background: #23a559; }
.btn-decline { background: #fa777c; }

/* Hidden Inputs */
#pfp-upload, #file-upload { display: none; }
</style>
</head>
<body>

<nav class="servers">
    <div class="server-icon active"><i class="fa-brands fa-discord"></i></div>
</nav>

<div class="channels">
    <div class="server-header" id="server-name">Shooym Hub</div>
    <div class="channel-list">
        <div class="channel-item active" id="chan-general" onclick="switchChannel('general')">
            <span style="color:#888">#</span> General
        </div>
        <div class="channel-item" id="chan-cheating" onclick="switchChannel('cheating')">
            <span style="color:#888">#</span> Cheating General
        </div>
    </div>
    
    <div class="user-bar">
        <label for="pfp-upload" title="Change Profile Picture">
            <img src="" id="current-user-avatar" class="user-avatar-small">
        </label>
        <input type="file" id="pfp-upload" accept="image/*" onchange="uploadPfp(this)">
        
        <div class="user-info">
            <div id="display-username" onclick="changeName()" style="cursor:pointer">...</div>
            <div style="font-size: 0.7rem; color: #aaa;">Online</div>
        </div>
    </div>
</div>

<main class="chat-area">
    <header class="chat-header">
        <div><span style="color:var(--header-secondary); margin-right: 4px;">#</span> <span id="header-channel-name">general</span></div>
        <div id="role-badge" class="role-offline">Starting...</div>
    </header>

    <div id="chat-feed"></div>

    <div class="input-area">
        <div class="input-wrapper">
            <label for="file-upload" class="btn-icon" title="Send File (Img/PDF)">
                <i class="fa-solid fa-circle-plus"></i>
            </label>
            <input type="file" id="file-upload" accept="image/*,application/pdf" onchange="handleFileUpload(this)">
            
            <input type="text" id="msg-input" placeholder="Initializing..." disabled>
            <button onclick="clearMyHistory()" class="btn-icon" title="Wipe History"><i class="fa-solid fa-trash"></i></button>
        </div>
    </div>
</main>

<div id="context-menu">
    <div class="ctx-item" id="ctx-call-btn">
        <i class="fa-solid fa-phone"></i> Call User
    </div>
    <div class="ctx-item" onclick="document.getElementById('context-menu').style.display='none'">
        <i class="fa-solid fa-xmark"></i> Close
    </div>
</div>

<div id="call-modal">
    <div class="call-status" id="call-text">Incoming Call...</div>
    <div class="call-actions" id="call-buttons"></div>
</div>

<audio id="remote-audio" autoplay playsinline></audio>

<script>
    // --- CONFIGURATION ---
    const SHARED_SERVER_ID = "shooym-global-room-v12-fixed";
    const STORAGE_KEY = "shooym_history_v12";
    const PFP_KEY = "shooym_pfp_v1";

    // --- STATE ---
    let myName = localStorage.getItem("shooym_username");
    if(!myName) {
        myName = "User" + Math.floor(Math.random()*1000);
        localStorage.setItem("shooym_username", myName);
    }
    let myPfp = localStorage.getItem(PFP_KEY) || `https://ui-avatars.com/api/?name=${encodeURIComponent(myName)}&background=232428&color=fff`;

    let currentChannel = "general"; 
    
    let peer = null;
    let myRole = "offline"; 
    let connections = [];   
    let hostConn = null;    
    let messageHistory = [];
    let processedIds = new Set(); 
    let isMigrating = false;

    // --- CALLING STATE ---
    let currentCall = null;
    let localStream = null;

    // --- HEARTBEAT VARIABLES ---
    let lastHeartbeat = Date.now();
    let heartbeatInterval = null; 
    let monitorInterval = null;   

    // --- INITIALIZATION ---
    updateUI();
    loadHistory(); 
    initPeer();

    // --- GLOBAL CLICK TO CLOSE MENU ---
    document.addEventListener('click', (e) => {
        const menu = document.getElementById('context-menu');
        if (menu.style.display === 'block' && !e.target.closest('.username') && !e.target.closest('.avatar') && !e.target.closest('#context-menu')) {
            menu.style.display = 'none';
        }
    });

    // --- DEV MOD (Ctrl+Shift+J) ---
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && (e.key === 'J' || e.key === 'j')) {
            e.preventDefault();
            openDevMod();
        }
    });

    function openDevMod() {
        const win = window.open("", "_blank", "width=600,height=500,menubar=no,toolbar=no");
        if(!win) { alert("Pop-up blocked! Allow pop-ups for Dev Mode."); return; }

        let connectionHTML = "";
        let connectionCount = 0;

        if (myRole === 'host') {
            connections.forEach(conn => {
                if(conn.open) {
                    connectionHTML += `<li style="color:#23a559">Client ID: ${conn.peer}</li>`;
                    connectionCount++;
                }
            });
            if(connectionCount === 0) connectionHTML = "<li>No active clients connected.</li>";
        } else if (myRole === 'client') {
            if(hostConn && hostConn.open) {
                connectionHTML += `<li style="color:#5865f2">Connected to HOST: ${hostConn.peer}</li>`;
                connectionCount = 1;
            } else {
                connectionHTML += `<li style="color:#fa777c">Disconnected from Host.</li>`;
            }
        }

        const htmlContent = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>ShooymCord Dev Mode</title>
                <style>
                    body { background: #1e1f22; color: #dbdee1; font-family: monospace; padding: 20px; }
                    h2 { color: #5865f2; border-bottom: 2px solid #5865f2; padding-bottom: 5px; }
                    .section { margin-bottom: 20px; background: #2b2d31; padding: 15px; border-radius: 8px; }
                    ul { list-style: none; padding: 0; }
                    li { padding: 4px 0; border-bottom: 1px solid #444; }
                </style>
            </head>
            <body>
                <h1>üõ†Ô∏è Shooym Dev Panel</h1>
                <div class="section">
                    <h2>My Identity</h2>
                    <div><strong>Username:</strong> ${myName}</div>
                    <div><strong>Peer ID:</strong> ${peer ? peer.id : 'Initializing...'}</div>
                    <div><strong>Current Role:</strong> ${myRole}</div>
                    <div><strong>Last Heartbeat:</strong> ${Date.now() - lastHeartbeat}ms ago</div>
                </div>
                <div class="section">
                    <h2>Connection Map (${connectionCount} Active)</h2>
                    <ul>${connectionHTML}</ul>
                </div>
            </body>
            </html>
        `;
        win.document.write(htmlContent);
        win.document.close();
    }

    function initPeer() {
        if(isMigrating) return;
        console.log("Initializing Peer...");
        resetHeartbeats(); 

        // 1. Try to be HOST
        peer = new Peer(SHARED_SERVER_ID);

        peer.on('open', (id) => {
            becomeHost(id);
        });

        // 2. LISTEN FOR INCOMING CALLS
        peer.on('call', (call) => {
            console.log("Receiving call...");
            handleIncomingCall(call);
        });

        peer.on('error', (err) => {
            if(err.type === 'unavailable-id') {
                console.log("Host exists. Switching to Client.");
                becomeClient();
            } else {
                console.log("Peer Error:", err);
                if(err.type === 'peer-unavailable') { /* Ignore */ }
                else if(err.type === 'network') { setTimeout(initPeer, 5000); }
            }
        });
    }

    // --- CALLING LOGIC ---

    // 1. Show Context Menu
    function showUserMenu(e, targetPeerId, targetUsername) {
        e.stopPropagation();
        const menu = document.getElementById('context-menu');
        const btn = document.getElementById('ctx-call-btn');

        if (!targetPeerId || targetPeerId === 'undefined' || targetPeerId === peer.id) {
            btn.style.opacity = '0.5';
            btn.style.pointerEvents = 'none';
            btn.innerHTML = `<i class="fa-solid fa-phone-slash"></i> Cannot Call (Invalid ID)`;
        } else {
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
            btn.innerHTML = `<i class="fa-solid fa-phone"></i> Call ${targetUsername}`;
            btn.onclick = () => initiateCall(targetPeerId, targetUsername);
        }

        menu.style.display = 'block';
        menu.style.left = e.pageX + 'px';
        menu.style.top = e.pageY + 'px';
    }

    // 2. Start a Call
    function initiateCall(targetPeerId, username) {
        document.getElementById('context-menu').style.display = 'none';
        
        navigator.mediaDevices.getUserMedia({ audio: true, video: false })
            .then((stream) => {
                localStream = stream;
                showCallUI(`Calling ${username}...`, true);
                
                const call = peer.call(targetPeerId, stream);
                currentCall = call;

                call.on('stream', (remoteStream) => {
                    playStream(remoteStream);
                    showCallUI(`Connected to ${username}`, true);
                });

                call.on('close', endCall);
                call.on('error', (err) => { alert("Call Error: " + err); endCall(); });
            })
            .catch((err) => {
                alert("Microphone access denied or error: " + err);
            });
    }

    // 3. Handle Incoming Call
    function handleIncomingCall(call) {
        currentCall = call;
        showCallUI(`Incoming call from ${call.peer}...`, false, () => {
            // On Accept
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then((stream) => {
                    localStream = stream;
                    call.answer(stream); 
                    
                    call.on('stream', (remoteStream) => {
                        playStream(remoteStream);
                        showCallUI("Connected", true);
                    });
                    
                    call.on('close', endCall);
                })
                .catch(err => {
                    alert("No Mic Access");
                    endCall();
                });
        });
    }

    // 4. UI Helpers for Calls
    function showCallUI(text, isActive, onAccept) {
        const modal = document.getElementById('call-modal');
        const txt = document.getElementById('call-text');
        const btns = document.getElementById('call-buttons');
        
        modal.style.display = 'block';
        txt.innerText = text;
        btns.innerHTML = '';

        if (!isActive && onAccept) {
            // Incoming Call State
            const acceptBtn = document.createElement('button');
            acceptBtn.className = 'btn-call btn-accept';
            acceptBtn.innerHTML = '<i class="fa-solid fa-phone"></i> Accept';
            acceptBtn.onclick = onAccept;

            const declineBtn = document.createElement('button');
            declineBtn.className = 'btn-call btn-decline';
            declineBtn.innerHTML = '<i class="fa-solid fa-xmark"></i> Decline';
            declineBtn.onclick = endCall;

            btns.appendChild(acceptBtn);
            btns.appendChild(declineBtn);
        } else {
            // In Call / Calling State
            const endBtn = document.createElement('button');
            endBtn.className = 'btn-call btn-decline';
            endBtn.innerHTML = '<i class="fa-solid fa-phone-slash"></i> Hang Up';
            endBtn.onclick = endCall;
            btns.appendChild(endBtn);
        }
    }

    function playStream(stream) {
        const audio = document.getElementById('remote-audio');
        audio.srcObject = stream;
        audio.play().catch(e => console.log("Audio play failed (interaction needed):", e));
    }

    function endCall() {
        if(currentCall) currentCall.close();
        if(localStream) localStream.getTracks().forEach(track => track.stop());
        document.getElementById('call-modal').style.display = 'none';
        currentCall = null;
        localStream = null;
    }


    // --- CHANNEL SWITCHING LOGIC ---
    function switchChannel(channelId) {
        currentChannel = channelId;
        
        document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
        if(channelId === 'general') document.getElementById('chan-general').classList.add('active');
        if(channelId === 'cheating') document.getElementById('chan-cheating').classList.add('active');
        
        const displayName = channelId === 'general' ? 'general' : 'cheating genreal';
        document.getElementById('header-channel-name').innerText = displayName;
        
        if(!document.getElementById('msg-input').disabled) {
            document.getElementById('msg-input').placeholder = `Message #${displayName}`;
        }
        reRenderAllMessages();
    }

    // --- HOST LOGIC ---
    function becomeHost(id) {
        myRole = 'host';
        updateRoleDisplay("HOST (You)");
        enableChat();
        connections = [];

        // Ping Clients every 2 seconds
        heartbeatInterval = setInterval(() => { 
            broadcast({ type: 'ping' }); 
        }, 2000); 

        peer.on('connection', (conn) => {
            connections.push(conn);
            conn.on('open', () => {
                // Send history
                if(messageHistory.length > 0) {
                    messageHistory.forEach(msg => conn.send(msg));
                }
            });
            conn.on('data', (data) => {
                if(data.type === 'ping') return;
                if(data.type === 'history-merge') {
                    handleHistoryMerge(data.data);
                    return;
                }
                if (isNewMessage(data.id)) {
                    processIncomingData(data);
                    broadcast(data);
                }
            });
            conn.on('close', () => connections = connections.filter(c => c !== conn));
        });
    }

    function broadcast(data) {
        connections = connections.filter(c => c.open);
        connections.forEach(c => c.send(data));
    }

    // --- CLIENT LOGIC ---
    function becomeClient() {
        peer = new Peer(); 
        peer.on('open', () => {
            myRole = 'client';
            connectToHost();
        });
        // Important: Re-attach call listener for client mode
        peer.on('call', (call) => handleIncomingCall(call));
    }

    function connectToHost() {
        updateRoleDisplay("Connecting...");
        hostConn = peer.connect(SHARED_SERVER_ID);

        hostConn.on('open', () => {
            updateRoleDisplay("Connected");
            enableChat();
            
            // SYSTEM MESSAGE REMOVED HERE
            
            if(messageHistory.length > 0) {
                hostConn.send({
                    type: 'history-merge',
                    data: messageHistory
                });
            }
            
            lastHeartbeat = Date.now();
            monitorInterval = setInterval(checkHeartbeat, 2000); 
        });

        hostConn.on('data', (data) => {
            lastHeartbeat = Date.now(); // Any data counts as heartbeat
            
            if(data.type === 'ping') return;

            if (isNewMessage(data.id)) {
                processIncomingData(data);
            }
        });

        hostConn.on('close', () => {
            console.log("Host connection closed.");
            // Do NOT immediately migrate, wait for heartbeat check
        });
        
        peer.on('error', (err) => {
            console.log("Peer error in client mode:", err);
            // Only disconnect if critical
        });
    }

    // --- MERGE LOGIC ---
    function handleHistoryMerge(incomingHistory) {
        let dirty = false;
        incomingHistory.forEach(msg => {
            if(!processedIds.has(msg.id)) {
                processedIds.add(msg.id);
                messageHistory.push(msg);
                broadcast(msg);
                dirty = true;
            }
        });

        if(dirty) {
            messageHistory.sort((a, b) => a.timestamp - b.timestamp);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));
            reRenderAllMessages();
        }
    }

    // --- HEARTBEAT & DISCONNECT ---
    function checkHeartbeat() {
        if(myRole === 'host') return; // Hosts don't check heartbeat
        
        const timeSinceLast = Date.now() - lastHeartbeat;
        
        // If connection is actually open, force heartbeat update to prevent migration
        if (hostConn && hostConn.open) {
            if (timeSinceLast > 5000) lastHeartbeat = Date.now(); // Fake it if socket is alive
            return;
        }

        if (timeSinceLast > 10000) { // 10 Seconds timeout
            console.warn("HEARTBEAT LOST! Migrating...");
            handleHostDisconnect();
        }
    }

    function handleHostDisconnect() {
        if(isMigrating) return;
        isMigrating = true;
        resetHeartbeats(); 

        updateRoleDisplay("Host Dead! Migrating...", "migrating");
        disableChat();
        
        if(peer) peer.destroy();
        setTimeout(() => { isMigrating = false; initPeer(); }, Math.random() * 2000 + 1000);
    }

    function resetHeartbeats() {
        if(heartbeatInterval) clearInterval(heartbeatInterval);
        if(monitorInterval) clearInterval(monitorInterval);
    }

    // --- CORE MESSAGING ---
    function isNewMessage(id) {
        if(!id) return false;
        if(processedIds.has(id)) return false; 
        processedIds.add(id); 
        return true;
    }

    function processIncomingData(data) {
        const isOldMessage = (Date.now() - data.timestamp) > 5000;
        
        if(data.type === 'text' || data.type === 'image' || data.type === 'pdf') {
             messageHistory.push(data);
             if(messageHistory.length > 300) messageHistory.shift(); 
             localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));
        }

        if(data.channel === currentChannel || (!data.channel && currentChannel === 'general')) {
            if(isOldMessage) {
                messageHistory.sort((a, b) => a.timestamp - b.timestamp);
                reRenderAllMessages();
            } else {
                renderMessage(data);
            }
        }
    }

    function sendMessage() {
        const text = msgInput.value.trim();
        if (!text) return;
        
        const data = {
            id: Date.now().toString(36) + Math.random().toString(36).substr(2),
            user: myName,
            pfp: myPfp,
            msg: text,
            type: 'text',
            channel: currentChannel, 
            timestamp: Date.now(),
            peerId: peer.id // IMPORTANT: SEND MY ID SO OTHERS CAN CALL ME
        };

        if(isNewMessage(data.id)) {
            processIncomingData(data);
        }
        dispatch(data);
        msgInput.value = '';
    }

    function handleFileUpload(input) {
        const file = input.files[0];
        if (!file) return;
        if (file.size > 2000000) { alert("File too big! Limit is 2MB."); return; }

        const reader = new FileReader();
        reader.onload = function(e) {
            const data = {
                id: Date.now().toString(36) + Math.random(),
                user: myName,
                pfp: myPfp,
                fileData: e.target.result,
                fileName: file.name,
                type: file.type.includes('pdf') ? 'pdf' : 'image',
                channel: currentChannel,
                timestamp: Date.now(),
                peerId: peer.id // SEND ID
            };
            
            if(isNewMessage(data.id)) {
                renderMessage(data); 
                messageHistory.push(data);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));
            }
            dispatch(data);
        };
        reader.readAsDataURL(file);
    }

    function dispatch(data) {
        if (myRole === 'host') broadcast(data);
        else if (myRole === 'client' && hostConn && hostConn.open) hostConn.send(data);
    }

    // --- PFP & UI ---
    function uploadPfp(input) {
        const file = input.files[0];
        if(!file) return;
        if(file.size > 500000) { alert("PFP image too large! keep under 500kb"); return; }
        const reader = new FileReader();
        reader.onload = function(e) {
            myPfp = e.target.result;
            localStorage.setItem(PFP_KEY, myPfp);
            updateUI();
        }
        reader.readAsDataURL(file);
    }

    function changeName() {
        let newName = prompt("New Username:", myName);
        if(newName) {
            myName = newName;
            localStorage.setItem("shooym_username", myName);
            updateUI();
        }
    }

    function loadHistory() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if(saved) {
                messageHistory = JSON.parse(saved);
                reRenderAllMessages();
            }
        } catch(e) {}
    }

    function clearMyHistory() {
        if(confirm("Clear local history?")) {
            localStorage.removeItem(STORAGE_KEY);
            messageHistory = [];
            processedIds.clear();
            document.getElementById('chat-feed').innerHTML = '';
        }
    }

    function updateUI() {
        document.getElementById('display-username').innerText = myName;
        document.getElementById('current-user-avatar').src = myPfp;
    }

    function reRenderAllMessages() {
        const feed = document.getElementById('chat-feed');
        feed.innerHTML = '';
        
        messageHistory.forEach(msg => {
            const msgChannel = msg.channel || 'general';
            if(msgChannel === currentChannel) {
                processedIds.add(msg.id);
                renderMessage(msg);
            }
        });
    }

    function renderMessage(data) {
        const feed = document.getElementById('chat-feed');
        const date = new Date(data.timestamp);
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const avatar = data.pfp || `https://ui-avatars.com/api/?name=${encodeURIComponent(data.user)}`;

        let content = "";
        if (data.type === 'image') {
            content = `<img src="${data.fileData}" class="msg-img" onclick="window.open(this.src)">`;
        } else if (data.type === 'pdf') {
            content = `<a href="${data.fileData}" download="${data.fileName}" class="msg-file"><i class="fa-solid fa-file-pdf"></i> ${data.fileName}</a>`;
        } else {
            const tempDiv = document.createElement('div');
            tempDiv.textContent = data.msg;
            content = `<div class="message-text" style="color:#dbdee1; line-height:1.4">${tempDiv.innerHTML}</div>`;
        }

        // ADD ONCLICK TO OPEN CONTEXT MENU FOR CALLING
        const msgHTML = `
            <div class="message">
                <img src="${avatar}" class="avatar" onclick="showUserMenu(event, '${data.peerId}', '${data.user}')">
                <div class="message-content">
                    <div class="message-header">
                        <span class="username" onclick="showUserMenu(event, '${data.peerId}', '${data.user}')">${data.user}</span>
                        <span class="timestamp">${timeStr}</span>
                    </div>
                    ${content}
                </div>
            </div>`;

        feed.innerHTML += msgHTML;
        feed.scrollTop = feed.scrollHeight;
    }

    const msgInput = document.getElementById('msg-input');
    msgInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });

    function enableChat() { 
        msgInput.disabled = false; 
        const displayName = currentChannel === 'general' ? 'general' : 'cheating genreal';
        msgInput.placeholder = `Message #${displayName}`; 
    }
    function disableChat() { msgInput.disabled = true; msgInput.placeholder = "Searching for connection..."; }
    
    function updateRoleDisplay(text, specialClass) {
        const badge = document.getElementById('role-badge');
        badge.innerText = text;
        badge.className = ""; 
        if(specialClass) badge.classList.add('role-' + specialClass);
        else if(myRole === 'host') badge.classList.add('role-host');
        else if(text.includes("Connected")) badge.classList.add('role-client');
        else badge.classList.add('role-offline');
    }
</script>
</body>
</html>
